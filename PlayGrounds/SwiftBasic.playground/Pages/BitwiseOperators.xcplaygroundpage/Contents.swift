//: [Previous](@previous)

import Foundation

/**
 비트 연산
 

 

 


 

 
 
 */

// 1byte(8bit) 2 진수

//~ (not 연산자): 비트를 뒤집는다
//0-> 1, 1-> 0
let a: UInt8 = 0b0000_0010 //2
~a // 253
0b1111_1101 //253



//& (And 연산자)
//모든 비트가 1인경우에만 1, 나머지 경우는 0
let b: UInt8 = 0b0010_0010 //34
let c: UInt8 = 0b1100_1110 //206
b&c //2
0b0000_0010 //2



//| (Or 연산자)
//하나라도 1이면 1, 모두 0인경우는 0
b|c //238
0b1110_1110 //238


//^ - XOR (Exclusive OR)
//두 비트가 달라야 1, 같으면 0
b^c //236
0b1110_1100 //236


// << (Left Shife 연산자)
// 비트를 왼쪽으로 한칸씩 이동시킨다. 새로추가된 비트는 0이 저장됨
// 밖으로 비트가 나가면 사라짐
// *2 연산과 동일.
b<<1 // 34 * 2 = 68
0b0100_0100 // 68

// 2칸 이동 == *4 연산과 동일
// bitwise 연산은 비트를 직접 다루기 때문에 속도가 빠르다.
// 비트연산과 비교해도 곱하기 연산은 빠르기때문에 가독성이 좋은 곱하기 연산자를 쓰는게 더 낫다
b<<2 //136
b*4


// >> (Right Shift연산)
// 비트를 오른쪽으로 민다
// /2와 같음
b >> 1 // 34/2 = 17
b >> 2 // 34/4 = 8

// 논리 시프트 (Logical Shift)
// UInt8 은 unsigned integer. 부호비트를 고려할 필요 없다
// -> 비트연산이 단순 (밀려난 비트는 사라지고, 새로운 비트는 0 채움)




// 산술 시프트 (Arithmetic Shift)
// signed integer

// 오른쪽으로 밀려난 비트는 사라지고, 왼쪽에 추가된 비트는 기존에 있던 sign 비트가 채워진다
// => 사인비트가 0이면 0을 채우고, 1이면 1을 채움
//e >> 1



//: [Next](@next)
